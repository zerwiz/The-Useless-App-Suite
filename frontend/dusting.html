<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Digital Dusting - The Useless App Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;700;800&family=Space+Grotesk:wght@500;700&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="shared.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #030303;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            touch-action: none;
        }

        /* Base dust layer (Grey) */
        #dust-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            cursor: crosshair;
            pointer-events: none; /* Disabled until Begin is clicked */
        }
        
        #dust-canvas.enabled {
            pointer-events: auto; /* Enabled after Begin is clicked */
        }

        /* Residue layer (Purple) - Higher Z-index, harder to clear */
        #residue-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 11;
            pointer-events: none;
        }

        .reveal-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #0f172a, #450a0a, #1e1b4b);
            z-index: 5;
            overflow: hidden;
            user-select: none;
        }

        .hidden-text {
            position: absolute;
            color: rgba(255, 255, 255, 0.15);
            font-weight: 900;
            line-height: 0.8;
            white-space: nowrap;
            text-transform: uppercase;
            pointer-events: none;
            letter-spacing: -0.05em;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }

        .glass {
            position: absolute;
            background: #111;
            backdrop-filter: blur(20px);
            border: 6px solid #000;
            padding: 2rem 3rem;
            border-radius: 30px;
            color: white;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 1);
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
            will-change: left, top;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        .active-glow {
            box-shadow: 0 0 50px rgba(168, 85, 247, 0.5);
            border-color: #7e22ce;
        }

        #message-box {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: none;
        }

        .progress-container {
            width: 180px;
            height: 6px;
            background: rgba(255,255,255,0.05);
            margin-top: 20px;
            border-radius: 3px;
            overflow: hidden;
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background: #ffffff;
            transition: width 0.1s linear;
        }
        
        .entropy-warning {
            color: #ef4444;
            font-weight: bold;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .back-btn {
            z-index: 101;
        }
    </style>
</head>
<body>
    <div class="bg-glow"></div>
    <a href="../index.html" class="back-btn">‚Üê Back to Hub</a>

    <div class="reveal-background" id="bg-content"></div>

    <canvas id="dust-canvas"></canvas>
    <canvas id="residue-canvas"></canvas>

    <div class="ui-layer">
        <div id="stats-container" class="glass">
            <span id="timer" class="text-6xl font-mono tracking-tighter leading-none mb-2">10:00</span>
            <span id="status" class="text-[10px] uppercase tracking-[0.5em] opacity-40 text-center">Calibrating...</span>
            <div class="progress-container">
                <div id="progress-bar"></div>
            </div>
            <div id="warning-text" class="text-[8px] mt-3 tracking-[0.2em] uppercase opacity-0 transition-opacity">Critical Buildup</div>
        </div>
    </div>

    <div id="message-box" class="glass max-w-sm text-center pointer-events-auto">
        <p id="message-text" class="text-sm leading-relaxed"></p>
        <button onclick="closeMessage()" class="mt-5 w-full py-4 bg-white text-black rounded-xl text-xs font-black tracking-widest active:scale-95 transition-transform uppercase">Begin Labored Cleaning</button>
    </div>

    <script src="shared.js"></script>
    <script>
        const dustCanvas = document.getElementById('dust-canvas');
        const dustCtx = dustCanvas.getContext('2d', { willReadFrequently: true });
        
        const resCanvas = document.getElementById('residue-canvas');
        const resCtx = resCanvas.getContext('2d', { willReadFrequently: true });

        const timerEl = document.getElementById('timer');
        const statusEl = document.getElementById('status');
        const progressBar = document.getElementById('progress-bar');
        const statsContainer = document.getElementById('stats-container');
        const warningText = document.getElementById('warning-text');
        const msgBox = document.getElementById('message-box');
        const msgText = document.getElementById('message-text');
        const bgContent = document.getElementById('bg-content');

        // Audio System State
        let audioCtx;
        let whiteNoiseNode;
        let filterNode;
        let gainNode;

        function initAudio() {
            if (audioCtx && audioCtx.state !== 'closed') return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Audio context not available:', e);
                return;
            }
            
            // Create white noise buffer
            const bufferSize = 2 * audioCtx.sampleRate;
            const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            whiteNoiseNode = audioCtx.createBufferSource();
            whiteNoiseNode.buffer = noiseBuffer;
            whiteNoiseNode.loop = true;

            filterNode = audioCtx.createBiquadFilter();
            filterNode.type = 'bandpass';
            filterNode.frequency.value = 1000;
            filterNode.Q.value = 1;

            gainNode = audioCtx.createGain();
            gainNode.gain.value = 0;

            whiteNoiseNode.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            whiteNoiseNode.start();
        }

        let width, height;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let lastInteractionTime = Date.now();
        let hasBegun = false; // Track if user has clicked Begin
        
        let uiPos = { x: 0, y: 20 };
        
        const DUST_COLOR = '#222222';
        const PURPLE_DUST_COLOR = '#7e22ce'; 
        let totalSeconds = 600; 
        let secondsLeft = totalSeconds;
        let isComplete = false;

        const messages = [
            { text: "DISCIPLINE", size: "14vw", top: "40%", left: "5%" },
            { text: "CLEAN THE MIND", size: "4vw", top: "15%", left: "55%" },
            { text: "RESISTANCE IS GROWTH", size: "3vw", top: "8%", left: "10%" },
            { text: "FIGHT THE DECAY", size: "6vw", top: "70%", left: "15%" },
            { text: "NO REST", size: "10vw", top: "82%", left: "50%" },
            { text: "THE VOID RECLAIMS", size: "2.5vw", top: "25%", left: "5%" },
            { text: "PERSEVERE", size: "8vw", top: "55%", left: "45%" },
            { text: "LABOR IS CLARITY", size: "5vw", top: "12%", left: "30%" },
            { text: "MOMENTARY", size: "4.5vw", top: "65%", left: "60%" },
            { text: "SILENCE THE NOISE", size: "3vw", top: "35%", left: "70%" },
            { text: "EVERY INCH MATTERS", size: "3.2vw", top: "48%", left: "20%" },
            { text: "ENTROPY TRIUMPHS", size: "2.8vw", top: "92%", left: "10%" },
            { text: "DO NOT FALTER", size: "5vw", top: "30%", left: "55%" },
            { text: "WATCH IT RETURN", size: "3vw", top: "5%", left: "45%" },
            { text: "PURITY REQUIRES EFFORT", size: "2.5vw", top: "18%", left: "75%" },
            { text: "WIPE THE WORLD", size: "4vw", top: "45%", left: "40%" },
            { text: "DEEP FOCUS", size: "2vw", top: "3%", left: "80%" },
            { text: "UNFOLDING", size: "3.5vw", top: "60%", left: "80%" },
            { text: "STAY RELENTLESS", size: "2.2vw", top: "25%", left: "35%" }
        ];

        function initBackground() {
            bgContent.innerHTML = '';
            messages.forEach(m => {
                const el = document.createElement('div');
                el.className = 'hidden-text';
                el.innerText = m.text;
                el.style.fontSize = m.size;
                el.style.top = m.top;
                el.style.left = m.left;
                bgContent.appendChild(el);
            });
        }

        function updateResize() {
            width = window.innerWidth;
            height = window.innerHeight;
            
            dustCanvas.width = width;
            dustCanvas.height = height;
            resCanvas.width = width;
            resCanvas.height = height;

            fillWithDust();
            initBackground();
            
            uiPos.x = (width / 2) - (statsContainer.offsetWidth / 2);
            uiPos.y = 50;
            updateUIPlacement();
        }

        function updateUIPlacement() {
            statsContainer.style.left = `${uiPos.x}px`;
            statsContainer.style.top = `${uiPos.y}px`;
        }

        function fillWithDust() {
            dustCtx.globalCompositeOperation = 'source-over';
            dustCtx.fillStyle = DUST_COLOR;
            dustCtx.fillRect(0, 0, width, height);
            
            for (let i = 0; i < (width * height) / 8; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const size = Math.random() * 2.5;
                dustCtx.fillStyle = Math.random() > 0.5 ? '#000' : '#333';
                dustCtx.fillRect(x, y, size, size);
            }
            resCtx.clearRect(0, 0, width, height);
        }

        function spawnPurpleDust(x, y, force) {
            resCtx.globalCompositeOperation = 'source-over';
            const particleCount = Math.min(Math.floor(force * 12), 60);
            for (let i = 0; i < particleCount; i++) {
                const offsetX = (Math.random() - 0.5) * 120;
                const offsetY = (Math.random() - 0.5) * 120;
                const size = Math.random() * 12 + 4;
                resCtx.fillStyle = PURPLE_DUST_COLOR;
                resCtx.beginPath();
                resCtx.arc(x + offsetX, y + offsetY, size, 0, Math.PI * 2);
                resCtx.fill();
            }
        }

        function draw(e) {
            if (isComplete || !isDrawing) {
                if (gainNode && audioCtx && audioCtx.state === 'running') {
                    gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
                }
                return;
            }

            const x = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
            const y = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

            // Audio Modulation based on movement speed
            const dx = x - lastX;
            const dy = y - lastY;
            const speed = Math.sqrt(dx * dx + dy * dy);
            
            // Ensure audio is initialized before using it
            if (!audioCtx) {
                initAudio();
            }
            
            if (gainNode && audioCtx && audioCtx.state === 'running') {
                const volume = Math.min(speed / 150, 0.25);
                const freq = 600 + (speed * 15);
                gainNode.gain.setTargetAtTime(volume, audioCtx.currentTime, 0.02);
                filterNode.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.02);
            }

            const rect = statsContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dist = Math.hypot(x - centerX, y - centerY);
            const radius = rect.width / 1.7; 

            if (dist < radius) {
                const angle = Math.atan2(centerY - y, centerX - x);
                const force = (radius - dist) / 2.5;
                uiPos.x += Math.cos(angle) * force;
                uiPos.y += Math.sin(angle) * force;
                spawnPurpleDust(centerX, centerY, force);
                uiPos.x = Math.max(0, Math.min(width - rect.width, uiPos.x));
                uiPos.y = Math.max(0, Math.min(height - rect.height, uiPos.y));
                updateUIPlacement();
                statsContainer.classList.add('active-glow');
            } else {
                statsContainer.classList.remove('active-glow');
            }

            const brushSize = 35;
            dustCtx.globalCompositeOperation = 'destination-out';
            dustCtx.beginPath();
            dustCtx.lineWidth = brushSize;
            dustCtx.lineCap = 'round';
            dustCtx.lineJoin = 'round';
            dustCtx.moveTo(lastX, lastY);
            dustCtx.lineTo(x, y);
            dustCtx.stroke();

            resCtx.globalCompositeOperation = 'destination-out';
            resCtx.globalAlpha = 0.12; 
            resCtx.beginPath();
            resCtx.lineWidth = brushSize;
            resCtx.lineCap = 'round';
            resCtx.lineJoin = 'round';
            resCtx.moveTo(lastX, lastY);
            resCtx.lineTo(x, y);
            resCtx.stroke();
            resCtx.globalAlpha = 1.0;

            lastX = x;
            lastY = y;
            lastInteractionTime = Date.now();
            
            if (statusEl.innerText !== 'Fighting Entropy...') {
                statusEl.innerText = 'Fighting Entropy...';
                warningText.style.opacity = '0';
            }
        }

        function settleDust() {
            if (isComplete) return;
            const idleTime = Date.now() - lastInteractionTime;
            dustCtx.globalCompositeOperation = 'source-over';
            let settleRate;
            let particlesPerFrame;

            if (idleTime > 300) {
                settleRate = 0.35; 
                statusEl.innerText = 'Entropy Overwhelming';
                warningText.style.opacity = '1';
                warningText.classList.add('entropy-warning');
                particlesPerFrame = Math.min(300, (width * height) / 3000); 
            } else {
                settleRate = 0.06; 
                particlesPerFrame = Math.min(100, (width * height) / 6000);
            }
            
            dustCtx.globalAlpha = settleRate;
            for (let i = 0; i < particlesPerFrame; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const size = Math.random() * 8; 
                dustCtx.fillStyle = DUST_COLOR;
                dustCtx.beginPath();
                dustCtx.arc(x, y, size, 0, Math.PI * 2);
                dustCtx.fill();
            }
            dustCtx.globalAlpha = 1.0;
        }

        function updateTimer() {
            if (isComplete) return;
            const idleTime = Date.now() - lastInteractionTime;
            if (idleTime < 800 && secondsLeft > 0) {
                secondsLeft -= 1;
            } else if (idleTime >= 800 && secondsLeft < totalSeconds) {
                secondsLeft += 5; 
                if (secondsLeft > totalSeconds) secondsLeft = totalSeconds;
            }
            const mins = Math.floor(secondsLeft / 60);
            const secs = secondsLeft % 60;
            timerEl.innerText = `${mins}:${secs.toString().padStart(2, '0')}`;
            const progress = ((totalSeconds - secondsLeft) / totalSeconds) * 100;
            progressBar.style.width = `${progress}%`;
            if (secondsLeft <= 0) completeChallenge();
        }

        function completeChallenge() {
            isComplete = true;
            statusEl.innerText = 'PURE SILENCE';
            if (gainNode) gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
            showMessage("The battle is finished. You have mastered the constant flow of decay.");
            dustCanvas.style.transition = 'opacity 8s ease';
            dustCanvas.style.opacity = '0';
            resCanvas.style.transition = 'opacity 8s ease';
            resCanvas.style.opacity = '0';
            statsContainer.style.transition = 'opacity 4s ease';
            statsContainer.style.opacity = '0';
            setTimeout(() => {
                dustCanvas.style.display = 'none';
                resCanvas.style.display = 'none';
            }, 8000);
        }

        function showMessage(text) {
            msgText.innerText = text;
            msgBox.style.display = 'block';
        }

        function closeMessage() {
            hasBegun = true; // Enable drawing/swiping
            dustCanvas.classList.add('enabled'); // Enable canvas pointer events
            msgBox.style.display = 'none';
            lastInteractionTime = Date.now();
            initAudio(); // Initialize audio context after first user gesture
        }

        const start = (e) => {
            if (!hasBegun) return; // Don't allow drawing until Begin is clicked
            initAudio(); // Initialize audio on first user interaction
            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            isDrawing = true;
            const x = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
            const y = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
            lastX = x;
            lastY = y;
        };

        const stop = () => {
            isDrawing = false;
            statsContainer.classList.remove('active-glow');
            if (gainNode && audioCtx && audioCtx.state === 'running') {
                gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
            }
        };

        window.addEventListener('mousedown', start);
        window.addEventListener('touchstart', start);
        window.addEventListener('mousemove', draw);
        window.addEventListener('touchmove', (e) => {
            e.preventDefault();
            draw(e);
        }, { passive: false });
        window.addEventListener('mouseup', stop);
        window.addEventListener('touchend', stop);
        window.addEventListener('resize', updateResize);

        updateResize();
        showMessage("Residue Alert: The purple toxic dust is thick. It requires repeated swiping to clear. Brushing creates friction.");

        setInterval(updateTimer, 1000);
        
        function mainLoop() {
            settleDust();
            requestAnimationFrame(mainLoop);
        }
        mainLoop();
    </script>
</body>
</html>
